\documentclass{article}
\usepackage{proof}
\usepackage[paper=letterpaper]{geometry}

% replace with conference's preferred style.
\setlength{\parindent}{\bigskipamount}
\setlength{\parskip}{\medskipamount}

\title{On this Recursive Signature Stuff}
\author{Jason C. Reed \and Samuel G\'elineau}


\begin{document}
\maketitle

\begin{abstract}\em
To be written as the last step.
\end{abstract}

\section{Introduction}\label{Introduction}
Sometimes, you need to do type reconstruction for LF using higher-order unification but you don't know which order variables are eventually going to be in the context. Because of this, circular constraints may arise in the middle of unification, and you would like to know that this is acceptable. This paper provides such a justification, in the form of a sensible calculus which supports this kind of circularity.

In section \ref{Example}, we give an example illustrating what is a recursive signature and why they are useful. In section \ref{Calculus}, we give an LF-like calculus of terms which supports recursive signatures. In section \ref{Semantics}, we give semantics to our calculus by transforming the recursive signatures away. Finally, we conclude in section \ref{Conclusion} by encouraging the reader to try our prototype type checker.

\section{Example}\label{Example}
A multidimensional matrix is indexed by a list of sizes, one for each dimention. If we choose to encode this list using a unidimentional array, we end up in a situation where multidimensional matrices are indexed by multidimensional matrices. This is recursion we are talking about.

\section{Calculus}\label{Calculus}
The ordinary LF calculus is as follows, I assume?

\newcommand{\entails}{\vdash}
\newcommand{\kind}{~\mathop{\mathrm{kind}}}
\newcommand{\type}{\mathop{\mathbf{type}}}
\hspace*{\fill}
$\infer{\Gamma \entails \type \kind}{}$
\hspace*{\fill}
$\infer{\Gamma \entails \{x:A\}~K \kind}{\Gamma \entails A : \type & \Gamma,~x:A \entails K \kind}$
\hspace*{\fill}

\hspace*{\fill}
$\infer{\Gamma \entails x : \Gamma(x)}{}$
\hspace*{\fill}
$\infer{\Gamma \entails \{x:A\}~B : \type}{\Gamma \entails A : \type & \Gamma,~x:A \entails B : \type}$
\hspace*{\fill}

\hspace*{\fill}
$\infer{\Gamma \entails F~E : B[E/x]}{\Gamma \entails F : \{x:A\}~B & \Gamma \entails E : A}$
\hspace*{\fill}
$\infer{\Gamma \entails [x:A]~E : \{x:A\}~B}{\Gamma \entails A : \type & \Gamma,~x:A \entails E : B}$
\hspace*{\fill}

\section{Semantics}\label{Semantics}
Using the same translation as the one used to give semantics to refinement types, we obtain families of signatures which only ever refer to earlier families. This breaks the circularity, and therefore succeeds at explaining our recursive signatures using a language lacking them.

\section{Conclusion}\label{Conclusion}
Thus, recursive signatures rule. Plus, we have implemented a prototype which type checks recursive signatures using a two-pass procedure. In the first pass, we parse the entire list of signatures and accept them as axioms, bypassing all sanity checks. In the second pass, we check that each signature is valid under the current set of axioms, which includes the signature currently being checked. It works!

\section{Dummy Section}
Dummy citation \cite{kienzle2006challenge} to make bibtex succeed. Remove once the actual paper contains at least one citation.

\bibliographystyle{unsrt}
\bibliography{paper}
\end{document}
